package bayley.cipher;

import java.io.IOException;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.LinkedHashSet;
import java.util.SortedSet;
import java.util.TreeSet;

public class CipherSolver {

  protected final CipherDict dict;
  protected final Set<Character> alphabet;
  protected final Set<Character> knownCharacters;

  CipherSolver () throws IOException {
    this(
            Config.englishAlphabet,
            new LinkedHashSet<>(Config.englishKnownCharacters)
    );
  }

  /**
   * a CipherSolver uses a single dictionary to solve many ciphers
   *
   * @param alphabet set of valid characters in our cipher
   * @param knownCharacters set of characters in the alphabet that must map to themselves
   * @throws IOException if the dict doesn't exist or can't be read
   */
  CipherSolver (Set<Character> alphabet, LinkedHashSet<Character> knownCharacters)
          throws IOException {
    // read in the dictionary and create data structures for lookup
    dict = new TokenDict(alphabet, knownCharacters);
    this.alphabet = alphabet;
    this.knownCharacters = knownCharacters;
  }

  /**
   * Refine
   *
   * returns: a list of superciphers generated by matching word against dictionary
   */
  protected Set<Cipher> refine (final Cipher cipher, String scrambledWord) {
    Set<Cipher> results = new LinkedHashSet<>();
    for (String potentialMatch : dict.potentialMatches(cipher, scrambledWord)) {
      // get the Cipher implied by a match between the scrambled word and the dictionary word
      Cipher supercipher = cipher.match(scrambledWord, potentialMatch);
      if (supercipher != null) {
        results.add(supercipher);
      }
    }
    return results;
  }

  /**
   * Tokenize. upcase, validate, dedupe, and reorder the words favorably for our algorithm
   **/
  public SortedSet<ScrambledWordEntry> prepareScrambledWords (final String scrambled) {
    SortedSet<ScrambledWordEntry> scrambledWords = new TreeSet<>();
    // validate words and find a good order to examine them in (fewer matches and longer first)
    for (String scrambledWord : scrambled.toUpperCase().split(" ")) {
      // here we strip away punctuation and check for valid words
      // we need to allow words that precede punctuation but not words like "éclair"
      // if we see an unknown character that isn't at the end of the word we can't solve this
      // TLDR: if we see an alphabet character after an unknown character we return no solution
      boolean seenNonAlphabetCharacter = false;
      StringBuilder builder = new StringBuilder();
      for (Character c : scrambledWord.toCharArray()) {
        if (alphabet.contains(c)) {
          // can't solve a cipher with a word containing characters
          // not in the alphabet that aren't at the end (like punctuation)
          if (seenNonAlphabetCharacter) {
            System.out.println(String.format("Character %c isn't in our alphabet", c));
            return new TreeSet<>();
          }
          builder.append(c);
        } else {
          seenNonAlphabetCharacter = true;
        }
      }
      String strippedWord = builder.toString();
      // if this word was only punctuation (like the always tasteful em-dash "—") just skip it
      if (strippedWord.equals("")) {
        continue;
      }
      scrambledWords.add(new ScrambledWordEntry(strippedWord, dict.nSimilarWords(strippedWord)));
    }
    return scrambledWords;
  }

  public Set<String> solve (final String scrambled) {
    return solve(scrambled, false);
  }

  public Set<String> solve (final String scrambled, final boolean verbose) {
    SortedSet<ScrambledWordEntry> scrambledWordsOrdered = prepareScrambledWords(scrambled);
    Set<Cipher> candidateCiphers = new LinkedHashSet<>();
    // start with one candidate - an empty Cipher
    candidateCiphers.add(new Cipher(alphabet, knownCharacters));
    int nWords = 0;
    for (ScrambledWordEntry scrambledWordEntry : scrambledWordsOrdered) {
      String scrambledWord = scrambledWordEntry.scrambledWord;
      if (verbose) {
        System.out.printf(
                "Matching word %d of %d: Comparing \"%s\" against %d potential ciphers%n",
                ++nWords,
                scrambledWordsOrdered.size(),
                scrambledWord,
                candidateCiphers.size()
                );
      }

      // this will be the set of candidates for the next iteration
      Set<Cipher> newCandidateCiphers = new LinkedHashSet<>();
      // new candidate ciphers are superciphers of old candidates that also match the new word
      for (Cipher cipher : candidateCiphers) {
        if (cipher == null) {
          throw new RuntimeException("Got a null cypher somehow");
        }
        newCandidateCiphers.addAll(refine(cipher, scrambledWord));
      }
      candidateCiphers = newCandidateCiphers;
      if (candidateCiphers.isEmpty()) {
        return new HashSet<>();
      }
    }
    Set<String> results = new LinkedHashSet<>();
    for (Cipher solutionCipher : candidateCiphers) {
      String result = solutionCipher.decode(scrambled);
      results.add(result);
    }
    return results;

  }

  /**
   * ScrambledWordEntry is an internal class that helps us sort words from the scrambled string
   * such that ones with fewer dictionary matches and more letters can be matched first.
   * This prevents the number of possible solutions from getting out of hand.
   */
  private class ScrambledWordEntry implements Comparable<ScrambledWordEntry> {
    protected final String scrambledWord;
    private final int uniquenessRank;

    ScrambledWordEntry (String scrambledWord, int nDictMatches) {
      this.scrambledWord = scrambledWord;
      HashSet<Character> seenChars = new HashSet<>();
      for (Character c : scrambledWord.toCharArray()) {
        seenChars.add(c);
      }
      int nUniqueChars = seenChars.size();
      // we want to look at words with fewer dictionary matches and more characters first
      // no specific reason for this formula - it could probably be improved
      this.uniquenessRank = (100 * nDictMatches) / nUniqueChars;
    }

    @Override
    public int compareTo (ScrambledWordEntry swe) {
      if (uniquenessRank != swe.uniquenessRank) {
        return uniquenessRank - swe.uniquenessRank;
      }
      else {
        // If the words have the same uniquenessRank we don't care about the order.
        // We still need a natural ordering consistent with equals() though
        // so we break the tie with the default String ordering.
        return scrambledWord.compareTo(swe.scrambledWord);
      }

    }

    @Override
    public boolean equals (Object o) {
      // If the ScrambledWordEntry is compared with itself then return true
      if (o == this) {
        return true;
      }
      // Check if o is an instance of ScrambledWordEntry or not
      // ("null instanceof [type]" also returns false)
      if (!(o instanceof ScrambledWordEntry)) {
        return false;
      }
      ScrambledWordEntry swe = (ScrambledWordEntry) o;
      return scrambledWord.equals(swe.scrambledWord);
    }

    @Override
    public int hashCode () {
      return scrambledWord.hashCode();
    }
  }
}
