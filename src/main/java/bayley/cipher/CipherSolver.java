package bayley.cipher;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import java.util.LinkedHashSet;

public class CipherSolver {

  protected final CipherDict dict;
  protected final Set<Character> alphabet;
  protected final Set<Character> knownCharacters;

  CipherSolver () throws IOException {
    this(
            Config.englishAlphabet,
            new LinkedHashSet<>(Config.englishKnownCharacters)
    );
  }

  /**
   * a CipherSolver uses a single dictionary to solve many ciphers
   *
   * @param alphabet set of valid characters in our cipher
   * @param knownCharacters set of characters in the alphabet that must map to themselves
   * @throws IOException if the dict doesn't exist or can't be read
   */
  CipherSolver (Set<Character> alphabet, LinkedHashSet<Character> knownCharacters)
          throws IOException {
    // read in the dictionary and create data structures for lookup
    dict = new TokenDict(alphabet, knownCharacters);
    this.alphabet = alphabet;
    this.knownCharacters = knownCharacters;
  }

  /**
   * Refine
   *
   * returns: a list of superciphers generated by matching word against dictionary
   */
  protected Set<Cipher> refine (final Cipher cipher, String scrambledWord) {
    Set<Cipher> results = new LinkedHashSet<>();
    for (String potentialMatch : dict.potentialMatches(cipher, scrambledWord)) {
      // get the Cipher implied by a match between the scrambled word and the dictionary word
      Cipher supercipher = cipher.match(scrambledWord, potentialMatch);
      if (supercipher != null) {
        results.add(supercipher);
      }
    }
    return results;
  }

  public Set<String> solve (final String scrambled) {
    String[] scrambledWords = scrambled.split(" ");
    Set<Cipher> candidateCiphers = new LinkedHashSet<>();
    // start with one candidate - an empty Cipher
    candidateCiphers.add(new Cipher(alphabet, knownCharacters));
    for (String scrambledWord : scrambledWords) {
      scrambledWord = scrambledWord.toUpperCase();
      // here we strip away punctuation and check for valid words
      // we need to allow words that precede punctuation but not words like "éclair"
      // if we see an unknown character that isn't at the end of the word we can't solve this
      // TLDR: if we see an alphabet character after an unknown character we return no solution
      boolean seenNonAlphabetCharacter = false;
      StringBuilder builder = new StringBuilder();
      for (Character c : scrambledWord.toCharArray()) {
        if (alphabet.contains(c)) {
          // can't solve a cipher with a word containing characters
          // not in the alphabet that aren't at the end (like punctuation)
          if (seenNonAlphabetCharacter) {
            System.out.println(String.format("Character %c isn't in our alphabet", c));
            return new HashSet<>();
          }
          builder.append(c);
        }
        else {
          seenNonAlphabetCharacter = true;
        }
      }
      String strippedWord = builder.toString();
      // if this word was only punctuation (like the always tasteful em-dash "—") just skip it
      if (strippedWord.equals("")) {
        continue;
      }
      // this will be the set of candidates for the next iteration
      Set<Cipher> newCandidateCiphers = new LinkedHashSet<>();
      // new candidate ciphers are superciphers of old candidates that also match the new word
      for (Cipher cipher : candidateCiphers) {
        if (cipher == null) {
          throw new RuntimeException("Got a null cypher somehow");
        }
        newCandidateCiphers.addAll(refine(cipher, strippedWord));
      }
      candidateCiphers = newCandidateCiphers;
      if (candidateCiphers.isEmpty()) {
        return new HashSet<>();
      }
    }
    Set<String> results = new LinkedHashSet<>();
    for (Cipher solutionCipher : candidateCiphers) {
      String result = solutionCipher.decode(scrambled);
      results.add(result);
    }
    return results;

  }
}
