package bayley.cipher;

import java.io.IOException;
import java.util.*;

public class CipherSolver {

  protected final CipherDict dict;
  protected final Set<Character> alphabet;
  protected final Set<Character> knownCharacters;

  CipherSolver() throws IOException {
    this(Constants.ENGLISH_ALPHABET, Constants.ENGLISH_KNOWN_CHARACTERS);
  }

  /**
   * a CipherSolver uses a single dictionary to solve many cipher problems
   *
   * @param alphabet set of valid characters in our cipher
   * @param knownCharacters set of characters in the alphabet that must map to themselves
   * @throws IOException if the dict doesn't exist or can't be read
   */
  CipherSolver(Set<Character> alphabet, Set<Character> knownCharacters)
          throws IOException {
    // read in the dictionary and create data structures for lookup
    this.dict = new TokenDict(alphabet, knownCharacters);
    this.alphabet = alphabet;
    this.knownCharacters = knownCharacters;
  }

  /**
   * returns: a set of superciphers generated by matching word against dictionary
   */
  protected Set<Cipher> refine(final Cipher cipher, String scrambledWord) {
    Set<Cipher> results = new HashSet<>();
    for (String potentialMatch : dict.potentialMatches(cipher, scrambledWord)) {
      // get the Cipher implied by a match between the scrambled word and the dictionary word
      Cipher supercipher = cipher.match(scrambledWord, potentialMatch);
      if (supercipher != null) {
        results.add(supercipher);
      }
    }
    return results;
  }

  /**
   * Tokenize. upcase, validate, dedupe, and reorder the words favorably for our algorithm
   **/
  public List<String> prepareScrambledWords(final String scrambled) {
    SortedSet<ScrambledWordEntry> scrambledWords = new TreeSet<>();
    // validate words and find a good order to examine them in (fewer matches and longer first)
    for (String scrambledWord : scrambled.toUpperCase().split(" ")) {
      // here we strip away punctuation and check for valid words
      // we need to allow words that precede punctuation but not words like "éclair"
      // if we see an unknown character that isn't at the end of the word we can't solve this
      // TLDR: if we see an alphabet character after an unknown character we return no solution
      boolean seenNonAlphabetCharacter = false;
      StringBuilder builder = new StringBuilder();
      for (Character c : scrambledWord.toCharArray()) {
        if (alphabet.contains(c)) {
          // can't solve a cipher with a word containing characters
          // not in the alphabet that aren't at the end (like punctuation)
          if (seenNonAlphabetCharacter) {
            System.out.println(String.format("Character %c isn't in our alphabet", c));
            return Collections.emptyList();
          }
          builder.append(c);
        } else {
          seenNonAlphabetCharacter = true;
        }
      }
      String strippedWord = builder.toString();
      // if this word was only punctuation (like the always tasteful em-dash "—") just skip it
      if (strippedWord.equals("")) {
        continue;
      }
      scrambledWords.add(new ScrambledWordEntry(strippedWord, dict.nSimilarWords(strippedWord)));
    }
    List<String> scrambledWordsOrdered = new ArrayList<>(scrambledWords.size());
    scrambledWords.forEach(x -> scrambledWordsOrdered.add(x.scrambledWord));
    return Collections.unmodifiableList(scrambledWordsOrdered);
  }

  /**
   * ScrambledWordEntry is an internal class that helps us sort words from the scrambled string
   * such that ones with fewer dictionary matches and more letters can be matched first.
   * This prevents the number of possible solutions from getting out of hand.
   */
  private class ScrambledWordEntry implements Comparable<ScrambledWordEntry> {
    protected final String scrambledWord;
    private final int similarityScore;

    ScrambledWordEntry(String scrambledWord, int nDictMatches) {
      this.scrambledWord = scrambledWord;
      int nUniqueChars = (int) scrambledWord.chars().distinct().count();
      // we want to look at words with fewer dictionary matches and more characters first
      // we'll multiply by 10000 to retain resolution in the integer division but there is
      // no specific reason for this formula - it could probably be improved
      this.similarityScore = (10000 * nDictMatches) / nUniqueChars;
    }

    @Override
    public int compareTo(ScrambledWordEntry swe) {
      if (similarityScore != swe.similarityScore) {
        return similarityScore - swe.similarityScore;
      }
      else {
        // If the words have the same uniquenessRank we don't care about the order.
        // We still need a natural ordering consistent with equals() though
        // so we break the tie with the default String ordering.
        return scrambledWord.compareTo(swe.scrambledWord);
      }
    }

    @Override
    public boolean equals(Object o) {
      // If the ScrambledWordEntry is compared with itself then return true
      if (o == this) {
        return true;
      }
      // Check if o is an instance of ScrambledWordEntry or not
      // ("null instanceof [type]" also returns false)
      if (!(o instanceof ScrambledWordEntry)) {
        return false;
      }
      ScrambledWordEntry swe = (ScrambledWordEntry) o;
      return scrambledWord.equals(swe.scrambledWord);
    }

    @Override
    public int hashCode() {
      return scrambledWord.hashCode();
    }
  }

  public Set<String> solve(final String scrambled) {
    return solve(scrambled, false);
  }

  public Set<String> solve(final String scrambled, boolean verbose) {
    List<String> scrambledWordsOrdered = prepareScrambledWords(scrambled);
    Set<Cipher> candidateCiphers = new HashSet<>();
    // start with one candidate - an empty Cipher except for the known characters
    candidateCiphers.add(new Cipher(alphabet, knownCharacters));
    int nWords = 0;
    for (String scrambledWord : scrambledWordsOrdered) {
      if (verbose) {
        System.out.printf(
                "Matching word %d of %d: Comparing \"%s\" against %d potential ciphers%n",
                ++nWords,
                scrambledWordsOrdered.size(),
                scrambledWord,
                candidateCiphers.size()
                );
      }

      // this will be the set of candidates for the next iteration
      Set<Cipher> newCandidateCiphers = new HashSet<>();
      // new candidate ciphers are superciphers of old candidates that also match the new word
      for (Cipher cipher : candidateCiphers) {
        if (cipher == null) {
          throw new RuntimeException("Got a null cypher somehow");
        }
        newCandidateCiphers.addAll(refine(cipher, scrambledWord));
      }
      candidateCiphers = newCandidateCiphers;
      if (candidateCiphers.isEmpty()) {
        // no candidate ciphers means we have no solutions
        return Collections.emptySet();
      }
    }
    Set<String> solutions = new HashSet<>();
    candidateCiphers.forEach(c -> solutions.add(c.decode(scrambled)));
    return solutions;
  }
}
